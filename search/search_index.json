{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Task 1: Theoretical Foundation 1.1 Equations of Motion for Projectile Motion The governing equations of motion for a projectile are derived from the basic principles of physics: Newton's Laws of Motion and the equations of constant acceleration . We will assume there is no air resistance in this idealized scenario. Horizontal Motion: \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] where: - \\(x(t)\\) is the horizontal position at time \\(t\\) , - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(t\\) is the time. Vertical Motion: \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] where: - \\(y(t)\\) is the vertical position at time \\(t\\) , - \\(g\\) is the acceleration due to gravity ( \\(9.81 \\, \\text{m/s}^2\\) ). These two equations describe the horizontal and vertical positions of the projectile at any given time \\(t\\) . 1.2 Time of Flight The time of flight is the total time the projectile remains in the air before it hits the ground. To find this, we set the vertical position equal to zero at the time of impact: \\[ y(t_f) = 0 \\] Substitute the vertical motion equation: \\[ v_0 \\sin(\\theta) \\cdot t_f - \\frac{1}{2} g t_f^2 = 0 \\] Factoring out \\(t_f\\) : \\[ t_f \\left( v_0 \\sin(\\theta) - \\frac{1}{2} g t_f \\right) = 0 \\] Solving for \\(t_f\\) (ignoring the trivial solution \\(t_f = 0\\) ): \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Thus, the time of flight depends on the initial velocity \\(v_0\\) and the angle of projection \\(\\theta\\) . 1.3 Range of the Projectile The range \\(R\\) is the horizontal distance the projectile travels before hitting the ground. It is given by the horizontal motion equation at the time of flight \\(t_f\\) : \\[ R = x(t_f) = v_0 \\cdot \\cos(\\theta) \\cdot t_f \\] Substitute the time of flight \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\) into the equation for range: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplifying: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the formula for the range of a projectile. 1.4 Family of Solutions Based on Initial Conditions The range \\(R\\) depends on two variables: the initial velocity \\(v_0\\) and the angle of projection \\(\\theta\\) . Effect of Initial Velocity \\(v_0\\) : A higher initial velocity increases the range. Effect of Angle of Projection \\(\\theta\\) : The range \\(R\\) is a function of \\(\\sin(2\\theta)\\) . Therefore, the range will be maximized when \\(\\theta = 45^\\circ\\) , since \\(\\sin(90^\\circ) = 1\\) . By varying the initial velocity or launch angle, we obtain a family of solutions describing the projectile's behavior. Task 2: Analysis of the Range Investigating the Dependence of Range on Angle of Projection The horizontal range \\(R\\) of a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) is given by the standard kinematic equation: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(g\\) is the acceleration due to gravity. Key Observations: Effect of Angle ( \\(\\theta\\) ): The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at \\(\\theta = 45^\\circ\\) . For angles greater or smaller than \\(45^\\circ\\) , the range decreases symmetrically. Effect of Initial Velocity ( \\(v_0\\) ): Since \\(R \\propto v_0^2\\) , doubling the initial velocity results in a fourfold increase in range. Effect of Gravitational Acceleration ( \\(g\\) ): The range is inversely proportional to \\(g\\) , meaning a lower gravitational field (such as on the Moon) results in a longer range, while a higher gravitational field (such as on Jupiter) results in a shorter range. Influence of Other Parameters Air Resistance: The idealized equation assumes no air resistance. In reality, drag reduces the range, and the optimal angle shifts slightly below \\(45^\\circ\\) . Altitude Variations: Changes in \\(g\\) due to altitude can affect the range. Wind Effects: A tailwind increases range, while a headwind decreases it. Task 3 : Practical Applications of Projectile Motion Adapting the Model for Real-World Scenarios The idealized model of projectile motion assumes uniform gravitational acceleration, no air resistance, and a flat launch and landing surface. However, real-world scenarios often involve additional complexities. Below are some practical applications and modifications of the model: 1. Projectiles on Uneven Terrain In mountainous or hilly regions, the launch and landing points may be at different elevations. The range equation must be modified to account for varying heights using the kinematic equation: $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where \\(y\\) represents the vertical displacement. - Adjustments are made by solving for the total flight time considering different initial and final heights. 2. Air Resistance and Drag Effects In practical cases, air resistance significantly affects projectile motion, reducing the range. The motion can be modeled using drag force \\(F_d\\) : $$ F_d = \\frac{1}{2} C_d \\rho A v^2 $$ where: - \\(C_d\\) is the drag coefficient, - \\(\\rho\\) is air density, - \\(A\\) is the cross-sectional area, - \\(v\\) is the velocity. - Numerical simulations are used to approximate projectile trajectories under these conditions. 3. Sports and Ballistics Applications Sports (Football, Basketball, Golf, etc.): Air resistance and spin play crucial roles. The Magnus effect explains curving trajectories due to spin. Military and Space Applications: Artillery and missile trajectories account for drag, wind, and Coriolis force due to Earth's rotation. Rocket Launches: Rockets experience varying gravitational fields and atmospheric densities, requiring advanced modeling. Task 4 : Implementation import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s^2) # Function to calculate the range of a projectile def calculate_range(angle_deg, v0, g): angle_rad = np.radians(angle_deg) # Convert angle to radians return (v0**2 * np.sin(2 * angle_rad)) / g # Function to simulate and plot range vs angle for different initial velocities def simulate_projectile_motion(initial_velocities): angles = np.linspace(0, 90, 100) # Angles from 0\u00b0 to 90\u00b0 plt.figure(figsize=(10, 6)) for v0 in initial_velocities: ranges = [calculate_range(angle, v0, g) for angle in angles] plt.plot(angles, ranges, label=f\"v0 = {v0} m/s\") plt.title(\"Range of a Projectile as a Function of Angle of Projection\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.show() # Initial velocities to test initial_velocities = [20, 40, 60, 80] # Different initial velocities (m/s)","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-1-theoretical-foundation","text":"","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion-for-projectile-motion","text":"The governing equations of motion for a projectile are derived from the basic principles of physics: Newton's Laws of Motion and the equations of constant acceleration . We will assume there is no air resistance in this idealized scenario.","title":"1.1 Equations of Motion for Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"\\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] where: - \\(x(t)\\) is the horizontal position at time \\(t\\) , - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(t\\) is the time.","title":"Horizontal Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"\\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] where: - \\(y(t)\\) is the vertical position at time \\(t\\) , - \\(g\\) is the acceleration due to gravity ( \\(9.81 \\, \\text{m/s}^2\\) ). These two equations describe the horizontal and vertical positions of the projectile at any given time \\(t\\) .","title":"Vertical Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"The time of flight is the total time the projectile remains in the air before it hits the ground. To find this, we set the vertical position equal to zero at the time of impact: \\[ y(t_f) = 0 \\] Substitute the vertical motion equation: \\[ v_0 \\sin(\\theta) \\cdot t_f - \\frac{1}{2} g t_f^2 = 0 \\] Factoring out \\(t_f\\) : \\[ t_f \\left( v_0 \\sin(\\theta) - \\frac{1}{2} g t_f \\right) = 0 \\] Solving for \\(t_f\\) (ignoring the trivial solution \\(t_f = 0\\) ): \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Thus, the time of flight depends on the initial velocity \\(v_0\\) and the angle of projection \\(\\theta\\) .","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range-of-the-projectile","text":"The range \\(R\\) is the horizontal distance the projectile travels before hitting the ground. It is given by the horizontal motion equation at the time of flight \\(t_f\\) : \\[ R = x(t_f) = v_0 \\cdot \\cos(\\theta) \\cdot t_f \\] Substitute the time of flight \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\) into the equation for range: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplifying: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the formula for the range of a projectile.","title":"1.3 Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-family-of-solutions-based-on-initial-conditions","text":"The range \\(R\\) depends on two variables: the initial velocity \\(v_0\\) and the angle of projection \\(\\theta\\) . Effect of Initial Velocity \\(v_0\\) : A higher initial velocity increases the range. Effect of Angle of Projection \\(\\theta\\) : The range \\(R\\) is a function of \\(\\sin(2\\theta)\\) . Therefore, the range will be maximized when \\(\\theta = 45^\\circ\\) , since \\(\\sin(90^\\circ) = 1\\) . By varying the initial velocity or launch angle, we obtain a family of solutions describing the projectile's behavior.","title":"1.4 Family of Solutions Based on Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-2-analysis-of-the-range","text":"","title":"Task 2: Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-dependence-of-range-on-angle-of-projection","text":"The horizontal range \\(R\\) of a projectile launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) is given by the standard kinematic equation: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(g\\) is the acceleration due to gravity.","title":"Investigating the Dependence of Range on Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"Effect of Angle ( \\(\\theta\\) ): The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at \\(\\theta = 45^\\circ\\) . For angles greater or smaller than \\(45^\\circ\\) , the range decreases symmetrically. Effect of Initial Velocity ( \\(v_0\\) ): Since \\(R \\propto v_0^2\\) , doubling the initial velocity results in a fourfold increase in range. Effect of Gravitational Acceleration ( \\(g\\) ): The range is inversely proportional to \\(g\\) , meaning a lower gravitational field (such as on the Moon) results in a longer range, while a higher gravitational field (such as on Jupiter) results in a shorter range.","title":"Key Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-other-parameters","text":"Air Resistance: The idealized equation assumes no air resistance. In reality, drag reduces the range, and the optimal angle shifts slightly below \\(45^\\circ\\) . Altitude Variations: Changes in \\(g\\) due to altitude can affect the range. Wind Effects: A tailwind increases range, while a headwind decreases it.","title":"Influence of Other Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-3-practical-applications-of-projectile-motion","text":"","title":"Task 3 : Practical Applications of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#adapting-the-model-for-real-world-scenarios","text":"The idealized model of projectile motion assumes uniform gravitational acceleration, no air resistance, and a flat launch and landing surface. However, real-world scenarios often involve additional complexities. Below are some practical applications and modifications of the model:","title":"Adapting the Model for Real-World Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-projectiles-on-uneven-terrain","text":"In mountainous or hilly regions, the launch and landing points may be at different elevations. The range equation must be modified to account for varying heights using the kinematic equation: $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where \\(y\\) represents the vertical displacement. - Adjustments are made by solving for the total flight time considering different initial and final heights.","title":"1. Projectiles on Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-air-resistance-and-drag-effects","text":"In practical cases, air resistance significantly affects projectile motion, reducing the range. The motion can be modeled using drag force \\(F_d\\) : $$ F_d = \\frac{1}{2} C_d \\rho A v^2 $$ where: - \\(C_d\\) is the drag coefficient, - \\(\\rho\\) is air density, - \\(A\\) is the cross-sectional area, - \\(v\\) is the velocity. - Numerical simulations are used to approximate projectile trajectories under these conditions.","title":"2. Air Resistance and Drag Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-sports-and-ballistics-applications","text":"Sports (Football, Basketball, Golf, etc.): Air resistance and spin play crucial roles. The Magnus effect explains curving trajectories due to spin. Military and Space Applications: Artillery and missile trajectories account for drag, wind, and Coriolis force due to Earth's rotation. Rocket Launches: Rockets experience varying gravitational fields and atmospheric densities, requiring advanced modeling.","title":"3. Sports and Ballistics Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-4-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s^2) # Function to calculate the range of a projectile def calculate_range(angle_deg, v0, g): angle_rad = np.radians(angle_deg) # Convert angle to radians return (v0**2 * np.sin(2 * angle_rad)) / g # Function to simulate and plot range vs angle for different initial velocities def simulate_projectile_motion(initial_velocities): angles = np.linspace(0, 90, 100) # Angles from 0\u00b0 to 90\u00b0 plt.figure(figsize=(10, 6)) for v0 in initial_velocities: ranges = [calculate_range(angle, v0, g) for angle in angles] plt.plot(angles, ranges, label=f\"v0 = {v0} m/s\") plt.title(\"Range of a Projectile as a Function of Angle of Projection\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.show() # Initial velocities to test initial_velocities = [20, 40, 60, 80] # Different initial velocities (m/s)","title":"Task 4 : Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Task 1: Theoretical Foundation: Forced Damped Pendulum Governing Equation The motion of a forced damped pendulum is governed by the following second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency, - \\(t\\) is time. Small-Angle Approximation For small angles, we use the approximation: \\[ \\sin\\theta \\approx \\theta \\] Substituting this into the equation simplifies it to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\] This is a linear, non-homogeneous differential equation, which can be solved using the method of undetermined coefficients or by considering the system's natural and forced response. General Solution The solution consists of two parts: Homogeneous solution (solution to the undriven equation): $$ \\theta_h(t) = C_1 e^{r_1 t} + C_2 e^{r_2 t} $$ where \\(r_1\\) and \\(r_2\\) are the roots of the characteristic equation: $$ r^2 + br + \\frac{g}{L} = 0 $$ Particular solution (steady-state response due to the driving force): $$ \\theta_p(t) = \\Theta_0 \\cos(\\omega t - \\delta) $$ where \\(\\Theta_0\\) is the amplitude of oscillation, and \\(\\delta\\) is the phase shift. The full solution is: \\[ \\theta(t) = C_1 e^{r_1 t} + C_2 e^{r_2 t} + \\Theta_0 \\cos(\\omega t - \\delta) \\] For long times ( \\(t \\to \\infty\\) ), the transient terms ( \\(C_1 e^{r_1 t} + C_2 e^{r_2 t}\\) ) vanish due to damping, leaving only the steady-state oscillation. Resonance Condition Resonance occurs when the driving frequency \\(\\omega\\) matches the system's natural frequency: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the amplitude \\(\\Theta_0\\) of oscillations reaches a maximum: \\[ \\Theta_0 = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}} \\] As damping ( \\(b\\) ) decreases, the resonance peak becomes sharper, meaning the system absorbs more energy from the driving force. Implications of Resonance At resonance, the pendulum oscillates with large amplitude, potentially leading to chaotic motion for large angles. In real systems, excessive oscillations may lead to structural failure (e.g., bridges, buildings). Similar behavior is seen in electrical RLC circuits, where resonance maximizes current. Task 3 : Practical Applications of the Forced Damped Pendulum The forced damped pendulum serves as a model for various real-world systems where periodic forces interact with damping and restoring forces. Real-World Applications of Forced Oscillations 1. Energy Harvesting Devices Vibration-based energy harvesters convert mechanical motion into electrical energy. The voltage output of a piezoelectric harvester follows the equation: \\[ V(t) = V_0 e^{-\\gamma t} \\sin(\\omega t) \\] where: - \\( V_0 \\) is the initial voltage, - \\( \\gamma \\) is the damping coefficient, - \\( \\omega \\) is the oscillation frequency. 2. Suspension Bridges Suspension bridges can experience resonance due to wind forces, modeled by: \\[ x(t) = \\frac{F_0}{m} \\frac{\\sin(\\omega_{\\text{drive}} t)}{\\omega_0^2 - \\omega_{\\text{drive}}^2 + i \\gamma \\omega_{\\text{drive}}} \\] where: - \\( F_0 \\) is the driving force amplitude, - \\( m \\) is the mass, - \\( \\omega_0 \\) is the natural frequency, - \\( \\omega_{\\text{drive}} \\) is the driving frequency, - \\( \\gamma \\) is the damping coefficient. 3. Oscillating Circuits (RLC Circuit) An RLC circuit with an alternating current behaves as a forced harmonic oscillator: \\[ V(t) = V_0 e^{-\\gamma t} \\cos(\\omega t) \\] where: - \\( V_0 \\) is the initial voltage, - \\( \\gamma = \\frac{R}{2L} \\) is the damping coefficient, - \\( \\omega = \\frac{1}{\\sqrt{LC}} \\) is the resonance frequency. The impedance of the circuit as a function of frequency is: \\[ Z(\\omega) = \\sqrt{R^2 + \\left( \\omega L - \\frac{1}{\\omega C} \\right)^2} \\] 4. Clocks and Timekeeping Pendulum clocks maintain accurate oscillations using an external forcing mechanism: \\[ \\theta(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega t) + A \\sin(\\omega_{\\text{drive}} t) \\] where: - \\( \\theta_0 \\) is the initial angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( A \\) is the amplitude of the driving force. The period of a simple pendulum is given by: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] where \\( L \\) is the length of the pendulum and \\( g \\) is the acceleration due to gravity. 5. Human Movement & Biomechanics Biomechanics uses forced oscillation models to describe gait dynamics: \\[ \\theta_{\\text{leg}}(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega t) \\] where: - \\( \\theta_0 \\) is the initial leg angle, - \\( \\gamma \\) is the damping factor due to muscle resistance, - \\( \\omega \\) represents the natural swing frequency. The human gait cycle can also be modeled using a second-order differential equation: \\[ m \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + k\\theta = F_{\\text{drive}}(t) \\] where: - \\( m \\) is the effective mass of the leg, - \\( b \\) is the damping coefficient, - \\( k \\) is the stiffness, - \\( F_{\\text{drive}}(t) \\) is the external forcing function from muscles. Task 4 : Forced Damped Pendulum Simulation Introduction The forced damped pendulum is a physical system where the motion of a pendulum is influenced by both damping (resistive force) and an external periodic force. We are going to model this system using the following differential equation: \\[ \\theta''(t) + 2\\gamma \\theta'(t) + \\omega_0^2 \\sin(\\theta(t)) = A \\cos(\\omega t) \\] Where: - $ \\theta(t) $ is the angle of the pendulum as a function of time. - $ \\gamma $ is the damping coefficient. - $ \\omega_0 $ is the natural frequency of the pendulum (without damping). - $ A $ is the amplitude of the external driving force. - $ \\omega $ is the frequency of the external driving force. Step 1: Numerical Solution We will use the Runge-Kutta method to solve this second-order differential equation. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the system of ODEs def damped_pendulum(t, y, gamma, omega_0, A, omega): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -2 * gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # Parameters gamma = 0.1 # Damping coefficient omega_0 = 2.0 # Natural frequency A = 0.5 # Amplitude of the driving force omega = 1.0 # Driving frequency # Initial conditions theta_0 = 0.1 # Initial angle in radians theta_dot_0 = 0.0 # Initial angular velocity y0 = [theta_0, theta_dot_0] # Initial conditions # Time span for the simulation t_span = (0, 100) # Time interval for the simulation t_eval = np.linspace(t_span[0], t_span[1], 10000) # Time points for evaluation # Solve the ODE sol = solve_ivp(damped_pendulum, t_span, y0, args=(gamma, omega_0, A, omega), t_eval=t_eval) # Plot the results plt.figure(figsize=(10, 6)) plt.subplot(2, 1, 1) plt.plot(sol.t, sol.y[0], label='Angle (theta)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.subplot(2, 1, 2) plt.plot(sol.t, sol.y[1], label='Angular Velocity (theta_dot)', color='r') plt.xlabel('Time (s)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-1-theoretical-foundation-forced-damped-pendulum","text":"","title":"Task 1: Theoretical Foundation: Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is governed by the following second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the acceleration due to gravity, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the driving frequency, - \\(t\\) is time.","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles, we use the approximation: \\[ \\sin\\theta \\approx \\theta \\] Substituting this into the equation simplifies it to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\] This is a linear, non-homogeneous differential equation, which can be solved using the method of undetermined coefficients or by considering the system's natural and forced response.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#general-solution","text":"The solution consists of two parts: Homogeneous solution (solution to the undriven equation): $$ \\theta_h(t) = C_1 e^{r_1 t} + C_2 e^{r_2 t} $$ where \\(r_1\\) and \\(r_2\\) are the roots of the characteristic equation: $$ r^2 + br + \\frac{g}{L} = 0 $$ Particular solution (steady-state response due to the driving force): $$ \\theta_p(t) = \\Theta_0 \\cos(\\omega t - \\delta) $$ where \\(\\Theta_0\\) is the amplitude of oscillation, and \\(\\delta\\) is the phase shift. The full solution is: \\[ \\theta(t) = C_1 e^{r_1 t} + C_2 e^{r_2 t} + \\Theta_0 \\cos(\\omega t - \\delta) \\] For long times ( \\(t \\to \\infty\\) ), the transient terms ( \\(C_1 e^{r_1 t} + C_2 e^{r_2 t}\\) ) vanish due to damping, leaving only the steady-state oscillation.","title":"General Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the driving frequency \\(\\omega\\) matches the system's natural frequency: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the amplitude \\(\\Theta_0\\) of oscillations reaches a maximum: \\[ \\Theta_0 = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}} \\] As damping ( \\(b\\) ) decreases, the resonance peak becomes sharper, meaning the system absorbs more energy from the driving force.","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#implications-of-resonance","text":"At resonance, the pendulum oscillates with large amplitude, potentially leading to chaotic motion for large angles. In real systems, excessive oscillations may lead to structural failure (e.g., bridges, buildings). Similar behavior is seen in electrical RLC circuits, where resonance maximizes current.","title":"Implications of Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-3-practical-applications-of-the-forced-damped-pendulum","text":"The forced damped pendulum serves as a model for various real-world systems where periodic forces interact with damping and restoring forces.","title":"Task 3 : Practical Applications of the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#real-world-applications-of-forced-oscillations","text":"","title":"Real-World Applications of Forced Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-energy-harvesting-devices","text":"Vibration-based energy harvesters convert mechanical motion into electrical energy. The voltage output of a piezoelectric harvester follows the equation: \\[ V(t) = V_0 e^{-\\gamma t} \\sin(\\omega t) \\] where: - \\( V_0 \\) is the initial voltage, - \\( \\gamma \\) is the damping coefficient, - \\( \\omega \\) is the oscillation frequency.","title":"1. Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-suspension-bridges","text":"Suspension bridges can experience resonance due to wind forces, modeled by: \\[ x(t) = \\frac{F_0}{m} \\frac{\\sin(\\omega_{\\text{drive}} t)}{\\omega_0^2 - \\omega_{\\text{drive}}^2 + i \\gamma \\omega_{\\text{drive}}} \\] where: - \\( F_0 \\) is the driving force amplitude, - \\( m \\) is the mass, - \\( \\omega_0 \\) is the natural frequency, - \\( \\omega_{\\text{drive}} \\) is the driving frequency, - \\( \\gamma \\) is the damping coefficient.","title":"2. Suspension Bridges"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-oscillating-circuits-rlc-circuit","text":"An RLC circuit with an alternating current behaves as a forced harmonic oscillator: \\[ V(t) = V_0 e^{-\\gamma t} \\cos(\\omega t) \\] where: - \\( V_0 \\) is the initial voltage, - \\( \\gamma = \\frac{R}{2L} \\) is the damping coefficient, - \\( \\omega = \\frac{1}{\\sqrt{LC}} \\) is the resonance frequency. The impedance of the circuit as a function of frequency is: \\[ Z(\\omega) = \\sqrt{R^2 + \\left( \\omega L - \\frac{1}{\\omega C} \\right)^2} \\]","title":"3. Oscillating Circuits (RLC Circuit)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-clocks-and-timekeeping","text":"Pendulum clocks maintain accurate oscillations using an external forcing mechanism: \\[ \\theta(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega t) + A \\sin(\\omega_{\\text{drive}} t) \\] where: - \\( \\theta_0 \\) is the initial angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( A \\) is the amplitude of the driving force. The period of a simple pendulum is given by: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] where \\( L \\) is the length of the pendulum and \\( g \\) is the acceleration due to gravity.","title":"4. Clocks and Timekeeping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-human-movement-biomechanics","text":"Biomechanics uses forced oscillation models to describe gait dynamics: \\[ \\theta_{\\text{leg}}(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega t) \\] where: - \\( \\theta_0 \\) is the initial leg angle, - \\( \\gamma \\) is the damping factor due to muscle resistance, - \\( \\omega \\) represents the natural swing frequency. The human gait cycle can also be modeled using a second-order differential equation: \\[ m \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + k\\theta = F_{\\text{drive}}(t) \\] where: - \\( m \\) is the effective mass of the leg, - \\( b \\) is the damping coefficient, - \\( k \\) is the stiffness, - \\( F_{\\text{drive}}(t) \\) is the external forcing function from muscles.","title":"5. Human Movement &amp; Biomechanics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-4-forced-damped-pendulum-simulation","text":"","title":"Task 4 : Forced Damped Pendulum Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#introduction","text":"The forced damped pendulum is a physical system where the motion of a pendulum is influenced by both damping (resistive force) and an external periodic force. We are going to model this system using the following differential equation: \\[ \\theta''(t) + 2\\gamma \\theta'(t) + \\omega_0^2 \\sin(\\theta(t)) = A \\cos(\\omega t) \\] Where: - $ \\theta(t) $ is the angle of the pendulum as a function of time. - $ \\gamma $ is the damping coefficient. - $ \\omega_0 $ is the natural frequency of the pendulum (without damping). - $ A $ is the amplitude of the external driving force. - $ \\omega $ is the frequency of the external driving force.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-1-numerical-solution","text":"We will use the Runge-Kutta method to solve this second-order differential equation. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the system of ODEs def damped_pendulum(t, y, gamma, omega_0, A, omega): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -2 * gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # Parameters gamma = 0.1 # Damping coefficient omega_0 = 2.0 # Natural frequency A = 0.5 # Amplitude of the driving force omega = 1.0 # Driving frequency # Initial conditions theta_0 = 0.1 # Initial angle in radians theta_dot_0 = 0.0 # Initial angular velocity y0 = [theta_0, theta_dot_0] # Initial conditions # Time span for the simulation t_span = (0, 100) # Time interval for the simulation t_eval = np.linspace(t_span[0], t_span[1], 10000) # Time points for evaluation # Solve the ODE sol = solve_ivp(damped_pendulum, t_span, y0, args=(gamma, omega_0, A, omega), t_eval=t_eval) # Plot the results plt.figure(figsize=(10, 6)) plt.subplot(2, 1, 1) plt.plot(sol.t, sol.y[0], label='Angle (theta)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.subplot(2, 1, 2) plt.plot(sol.t, sol.y[1], label='Angular Velocity (theta_dot)', color='r') plt.xlabel('Time (s)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.tight_layout() plt.show()","title":"Step 1: Numerical Solution"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Task 1 : Derivation of Kepler's Third Law for Circular Orbits Kepler's Third Law states that the square of the orbital period \\(T\\) is proportional to the cube of the orbital radius \\(r\\) : \\[ T^2 \\propto r^3 \\] In this section, we derive this relationship using Newton's laws of motion and the law of universal gravitation. 1. Centripetal Force and Gravitational Force For a body in a circular orbit around a much larger mass (e.g., a planet orbiting a star), the centripetal force required to maintain the orbit is provided by the gravitational force : Centripetal Force The centripetal force acting on a body of mass \\(m\\) moving with velocity \\(v\\) in a circular orbit of radius \\(r\\) is: \\[ F_c = \\frac{m v^2}{r} \\] Gravitational Force The gravitational force exerted by a central mass \\(M\\) (e.g., the Sun) on the orbiting body is given by Newton's Law of Gravitation: \\[ F_g = \\frac{G M m}{r^2} \\] where: - \\(G\\) is the universal gravitational constant, - \\(M\\) is the mass of the central body, - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius. 2. Equating Forces Since gravity provides the necessary centripetal force, we set \\(F_c = F_g\\) : \\[ \\frac{m v^2}{r} = \\frac{G M m}{r^2} \\] Canceling \\(m\\) from both sides: \\[ \\frac{v^2}{r} = \\frac{G M}{r^2} \\] Multiplying both sides by \\(r\\) : \\[ v^2 = \\frac{G M}{r} \\] 3. Expressing Velocity in Terms of Orbital Period The orbital velocity \\(v\\) is related to the orbital period \\(T\\) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the equation: \\[ \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r} \\] Expanding: \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiplying both sides by \\(r\\) : \\[ 4\\pi^2 r^3 = G M T^2 \\] 4. Final Form of Kepler's Third Law Rearranging for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This shows that the square of the orbital period \\(T\\) is directly proportional to the cube of the orbital radius \\(r\\) : \\[ T^2 \\propto r^3 \\] This is Kepler's Third Law, which describes the relationship between the orbital period and the radius for objects in circular orbits around a massive central body. Task 2 : Discussion on the Implications of Kepler's Third Law for Astronomy Kepler's Third Law, which relates the square of a planet's orbital period ( \\(T\\) ) to the cube of its orbital radius ( \\(r\\) ), has significant implications in the field of astronomy. This law helps astronomers determine various aspects of planetary systems, such as the masses of planets and the distances between celestial objects. 1. Calculating Planetary Masses Kepler's Third Law can be modified to help calculate the mass of a central body, such as a planet or star, based on the orbital characteristics of its satellite or orbiting object. The modified version of Kepler's Third Law is: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] Where: - \\(T\\) is the orbital period, - \\(r\\) is the orbital radius, - \\(G\\) is the gravitational constant, and - \\(M\\) is the mass of the central body. From this equation, the mass of the central body ( \\(M\\) ) can be calculated as: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Thus, by knowing the orbital period and radius of an orbiting body (e.g., a moon or satellite), astronomers can calculate the mass of the planet or star it orbits. 2. Determining Distances in Space Kepler\u2019s Third Law also plays a crucial role in determining the distances between celestial bodies. By rearranging the law, astronomers can find the orbital radius of a planet, given the period of its orbit and the mass of the central body: \\[ r^3 = \\frac{G M T^2}{4 \\pi^2} \\] Knowing the orbital period ( \\(T\\) ) and the mass of the central body ( \\(M\\) ), the orbital radius ( \\(r\\) ) can be determined. This is particularly useful for calculating the distances between planets and their stars, or between moons and their planets. Task 3 : Real-World Examples of Kepler's Third Law: The Moon and Planetary Orbits Kepler's Third Law, which describes the relationship between the orbital period and the orbital radius of a body, has real-world applications in understanding the motion of celestial bodies such as the Moon and the planets in the Solar System. 1. The Moon's Orbit Around Earth The Moon orbits the Earth in an almost circular path, and its motion can be described using Kepler\u2019s Third Law. The orbital period of the Moon is approximately 27.3 days, and its average orbital radius is about 384,400 km. Using Kepler's Third Law, we can calculate the mass of the Earth based on the Moon's orbital period and radius. We know the gravitational constant ( \\(G\\) ) and the orbital period ( \\(T\\) ) of the Moon, so we can use the following formula: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Where: - \\(r\\) = 384,400 km (orbital radius of the Moon), - \\(T\\) = 27.3 days = 2,358,720 seconds (orbital period of the Moon), - \\(G\\) = \\(6.67430 \\times 10^{-11}\\) m \\(^3\\) kg \\(^{-1}\\) s \\(^{-2}\\) (gravitational constant). Plugging these values into the formula, we get the mass of the Earth. This calculation illustrates how Kepler's Third Law is used to determine the masses of celestial bodies. 2. The Orbits of Planets in the Solar System Kepler's Third Law is also fundamental in understanding the orbits of planets around the Sun. For example, the orbital period of Earth is about 365.25 days, and the average distance from Earth to the Sun is about 149.6 million kilometers (1 AU). Using Kepler\u2019s Third Law, we can compare the orbital characteristics of different planets in the Solar System. For example, the orbital period of Jupiter is 11.86 Earth years, and its average distance from the Sun is about 778.3 million kilometers. If we use Kepler\u2019s Third Law to compare the orbital periods and radii of Earth and Jupiter, we can predict the orbital behavior of these planets based on their distances from the Sun. The formula for Kepler\u2019s Third Law in this case is: \\[ \\frac{T_1^2}{r_1^3} = \\frac{T_2^2}{r_2^3} \\] Where: - \\(T_1\\) and \\(r_1\\) are the orbital period and radius of Earth, - \\(T_2\\) and \\(r_2\\) are the orbital period and radius of Jupiter. By substituting the known values for Earth and Jupiter, we can verify that Kepler's Third Law holds true across the Solar System and makes it possible to compare the motion of planets. Task 4 : Implementing a Computational Model to Simulate Circular Orbits In this task, we will implement a computational model to simulate circular orbits and verify the relationship between the orbital period and the orbital radius, as described by Kepler's Third Law. We will write a Python script to simulate the motion of a satellite orbiting a central body and calculate its orbital period based on its radius. 1. Kepler's Third Law and Circular Orbits Kepler's Third Law states that: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] Where: - \\(T\\) is the orbital period, - \\(r\\) is the orbital radius, - \\(G\\) is the gravitational constant, and - \\(M\\) is the mass of the central body. For circular orbits, we will simulate the motion of a satellite and calculate the orbital period for various orbital radii, using the above law. We can then compare the computed periods to the theoretical values to verify the relationship. 2. Python Script to Simulate Circular Orbits Below is a Python script that simulates circular orbits for different orbital radii and calculates the orbital period based on Kepler's Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) pi = np.pi # Function to calculate orbital period using Kepler's Third Law def orbital_period(r): T = 2 * pi * np.sqrt(r**3 / (G * M)) # Orbital period (seconds) return T # Range of orbital radii (in meters) radii = np.linspace(1e6, 1e8, 100) # From 1,000 km to 100,000 km # Calculate the orbital periods for each radius periods = orbital_period(radii) # Convert orbital period from seconds to days periods_days = periods / (60 * 60 * 24) # Plot the relationship between orbital period and orbital radius plt.figure (figsize=(8, 6)) plt.plot (radii, periods_days, label='Orbital Period', color='b') plt.xlabel ('Orbital Radius (m)') plt.ylabel ('Orbital Period (days)') plt.title ('Orbital Period vs Orbital Radius') plt. (True) plt.legend () plt.show () bodies = { 'Earth': 5.972e24, 'Mars': 6.39e23, 'Jupiter': 1.898e27 } plt.figure(figsize=(10,6)) for name, mass in bodies.items(): periods = 2*np.pi*np.sqrt(radii**3/(G*mass))/(60*60*24) plt.plot(radii, periods, label=name) plt.xlabel('Orbital Radius (m)') plt.ylabel('Period (days)') plt.title('Orbital Period for Different Central Bodies') plt.legend() plt.grid(True) plt.show() from mpl_toolkits.mplot3d import Axes3D theta = np.linspace(0, 2*np.pi, 100) r = 7e6 # LEO radius x = r * np.cos(theta) y = r * np.sin(theta) z = np.zeros_like(x) fig = plt.figure(figsize=(8,6)) ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, 'b-') ax.scatter([0], [0], [0], color='g', s=100) ax.set_title('Circular Orbit Visualization') plt.show()","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-1-derivation-of-keplers-third-law-for-circular-orbits","text":"Kepler's Third Law states that the square of the orbital period \\(T\\) is proportional to the cube of the orbital radius \\(r\\) : \\[ T^2 \\propto r^3 \\] In this section, we derive this relationship using Newton's laws of motion and the law of universal gravitation.","title":"Task 1 : Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-centripetal-force-and-gravitational-force","text":"For a body in a circular orbit around a much larger mass (e.g., a planet orbiting a star), the centripetal force required to maintain the orbit is provided by the gravitational force :","title":"1. Centripetal Force and Gravitational Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#centripetal-force","text":"The centripetal force acting on a body of mass \\(m\\) moving with velocity \\(v\\) in a circular orbit of radius \\(r\\) is: \\[ F_c = \\frac{m v^2}{r} \\]","title":"Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravitational-force","text":"The gravitational force exerted by a central mass \\(M\\) (e.g., the Sun) on the orbiting body is given by Newton's Law of Gravitation: \\[ F_g = \\frac{G M m}{r^2} \\] where: - \\(G\\) is the universal gravitational constant, - \\(M\\) is the mass of the central body, - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius.","title":"Gravitational Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-equating-forces","text":"Since gravity provides the necessary centripetal force, we set \\(F_c = F_g\\) : \\[ \\frac{m v^2}{r} = \\frac{G M m}{r^2} \\] Canceling \\(m\\) from both sides: \\[ \\frac{v^2}{r} = \\frac{G M}{r^2} \\] Multiplying both sides by \\(r\\) : \\[ v^2 = \\frac{G M}{r} \\]","title":"2. Equating Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-expressing-velocity-in-terms-of-orbital-period","text":"The orbital velocity \\(v\\) is related to the orbital period \\(T\\) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the equation: \\[ \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r} \\] Expanding: \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiplying both sides by \\(r\\) : \\[ 4\\pi^2 r^3 = G M T^2 \\]","title":"3. Expressing Velocity in Terms of Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-final-form-of-keplers-third-law","text":"Rearranging for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This shows that the square of the orbital period \\(T\\) is directly proportional to the cube of the orbital radius \\(r\\) : \\[ T^2 \\propto r^3 \\]","title":"4. Final Form of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#this-is-keplers-third-law-which-describes-the-relationship-between-the-orbital-period-and-the-radius-for-objects-in-circular-orbits-around-a-massive-central-body","text":"","title":"This is Kepler's Third Law, which describes the relationship between the orbital period and the radius for objects in circular orbits around a massive central body."},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-2-discussion-on-the-implications-of-keplers-third-law-for-astronomy","text":"Kepler's Third Law, which relates the square of a planet's orbital period ( \\(T\\) ) to the cube of its orbital radius ( \\(r\\) ), has significant implications in the field of astronomy. This law helps astronomers determine various aspects of planetary systems, such as the masses of planets and the distances between celestial objects.","title":"Task 2 : Discussion on the Implications of Kepler's Third Law for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-calculating-planetary-masses","text":"Kepler's Third Law can be modified to help calculate the mass of a central body, such as a planet or star, based on the orbital characteristics of its satellite or orbiting object. The modified version of Kepler's Third Law is: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] Where: - \\(T\\) is the orbital period, - \\(r\\) is the orbital radius, - \\(G\\) is the gravitational constant, and - \\(M\\) is the mass of the central body. From this equation, the mass of the central body ( \\(M\\) ) can be calculated as: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Thus, by knowing the orbital period and radius of an orbiting body (e.g., a moon or satellite), astronomers can calculate the mass of the planet or star it orbits.","title":"1. Calculating Planetary Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-determining-distances-in-space","text":"Kepler\u2019s Third Law also plays a crucial role in determining the distances between celestial bodies. By rearranging the law, astronomers can find the orbital radius of a planet, given the period of its orbit and the mass of the central body: \\[ r^3 = \\frac{G M T^2}{4 \\pi^2} \\] Knowing the orbital period ( \\(T\\) ) and the mass of the central body ( \\(M\\) ), the orbital radius ( \\(r\\) ) can be determined. This is particularly useful for calculating the distances between planets and their stars, or between moons and their planets.","title":"2. Determining Distances in Space"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-3-real-world-examples-of-keplers-third-law-the-moon-and-planetary-orbits","text":"Kepler's Third Law, which describes the relationship between the orbital period and the orbital radius of a body, has real-world applications in understanding the motion of celestial bodies such as the Moon and the planets in the Solar System.","title":"Task 3 : Real-World Examples of Kepler's Third Law: The Moon and Planetary Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-the-moons-orbit-around-earth","text":"The Moon orbits the Earth in an almost circular path, and its motion can be described using Kepler\u2019s Third Law. The orbital period of the Moon is approximately 27.3 days, and its average orbital radius is about 384,400 km. Using Kepler's Third Law, we can calculate the mass of the Earth based on the Moon's orbital period and radius. We know the gravitational constant ( \\(G\\) ) and the orbital period ( \\(T\\) ) of the Moon, so we can use the following formula: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] Where: - \\(r\\) = 384,400 km (orbital radius of the Moon), - \\(T\\) = 27.3 days = 2,358,720 seconds (orbital period of the Moon), - \\(G\\) = \\(6.67430 \\times 10^{-11}\\) m \\(^3\\) kg \\(^{-1}\\) s \\(^{-2}\\) (gravitational constant). Plugging these values into the formula, we get the mass of the Earth. This calculation illustrates how Kepler's Third Law is used to determine the masses of celestial bodies.","title":"1. The Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-the-orbits-of-planets-in-the-solar-system","text":"Kepler's Third Law is also fundamental in understanding the orbits of planets around the Sun. For example, the orbital period of Earth is about 365.25 days, and the average distance from Earth to the Sun is about 149.6 million kilometers (1 AU). Using Kepler\u2019s Third Law, we can compare the orbital characteristics of different planets in the Solar System. For example, the orbital period of Jupiter is 11.86 Earth years, and its average distance from the Sun is about 778.3 million kilometers. If we use Kepler\u2019s Third Law to compare the orbital periods and radii of Earth and Jupiter, we can predict the orbital behavior of these planets based on their distances from the Sun. The formula for Kepler\u2019s Third Law in this case is: \\[ \\frac{T_1^2}{r_1^3} = \\frac{T_2^2}{r_2^3} \\] Where: - \\(T_1\\) and \\(r_1\\) are the orbital period and radius of Earth, - \\(T_2\\) and \\(r_2\\) are the orbital period and radius of Jupiter. By substituting the known values for Earth and Jupiter, we can verify that Kepler's Third Law holds true across the Solar System and makes it possible to compare the motion of planets.","title":"2. The Orbits of Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task-4-implementing-a-computational-model-to-simulate-circular-orbits","text":"In this task, we will implement a computational model to simulate circular orbits and verify the relationship between the orbital period and the orbital radius, as described by Kepler's Third Law. We will write a Python script to simulate the motion of a satellite orbiting a central body and calculate its orbital period based on its radius.","title":"Task 4 : Implementing a Computational Model to Simulate Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-keplers-third-law-and-circular-orbits","text":"Kepler's Third Law states that: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] Where: - \\(T\\) is the orbital period, - \\(r\\) is the orbital radius, - \\(G\\) is the gravitational constant, and - \\(M\\) is the mass of the central body. For circular orbits, we will simulate the motion of a satellite and calculate the orbital period for various orbital radii, using the above law. We can then compare the computed periods to the theoretical values to verify the relationship.","title":"1. Kepler's Third Law and Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-python-script-to-simulate-circular-orbits","text":"Below is a Python script that simulates circular orbits for different orbital radii and calculates the orbital period based on Kepler's Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) pi = np.pi # Function to calculate orbital period using Kepler's Third Law def orbital_period(r): T = 2 * pi * np.sqrt(r**3 / (G * M)) # Orbital period (seconds) return T # Range of orbital radii (in meters) radii = np.linspace(1e6, 1e8, 100) # From 1,000 km to 100,000 km # Calculate the orbital periods for each radius periods = orbital_period(radii) # Convert orbital period from seconds to days periods_days = periods / (60 * 60 * 24) # Plot the relationship between orbital period and orbital radius plt.figure (figsize=(8, 6)) plt.plot (radii, periods_days, label='Orbital Period', color='b') plt.xlabel ('Orbital Radius (m)') plt.ylabel ('Orbital Period (days)') plt.title ('Orbital Period vs Orbital Radius') plt. (True) plt.legend () plt.show () bodies = { 'Earth': 5.972e24, 'Mars': 6.39e23, 'Jupiter': 1.898e27 } plt.figure(figsize=(10,6)) for name, mass in bodies.items(): periods = 2*np.pi*np.sqrt(radii**3/(G*mass))/(60*60*24) plt.plot(radii, periods, label=name) plt.xlabel('Orbital Radius (m)') plt.ylabel('Period (days)') plt.title('Orbital Period for Different Central Bodies') plt.legend() plt.grid(True) plt.show() from mpl_toolkits.mplot3d import Axes3D theta = np.linspace(0, 2*np.pi, 100) r = 7e6 # LEO radius x = r * np.cos(theta) y = r * np.sin(theta) z = np.zeros_like(x) fig = plt.figure(figsize=(8,6)) ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, 'b-') ax.scatter([0], [0], [0], color='g', s=100) ax.set_title('Circular Orbit Visualization') plt.show()","title":"2. Python Script to Simulate Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Task 1 : Defining the First, Second, and Third Cosmic Velocities The concept of cosmic velocities refers to the minimum speeds needed for an object to achieve certain objectives in space: orbiting a celestial body, escaping its gravitational influence, and leaving a star system. These velocities are fundamental for space exploration and understanding how spacecraft interact with gravitational fields. 1. First Cosmic Velocity: Orbital Velocity The first cosmic velocity is the minimum velocity an object must have to enter a stable orbit around a celestial body. This velocity ensures that the object moves fast enough such that its trajectory bends in a circle, counteracting the pull of gravity. The first cosmic velocity \\(v_1\\) can be calculated using the formula: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m \\(^3\\) kg \\(^{-1}\\) s \\(^{-2}\\) ), - \\(M\\) is the mass of the celestial body (e.g., Earth, the Moon), - \\(r\\) is the distance from the center of the celestial body to the object (orbital radius). This velocity represents the speed required to stay in a circular orbit without falling back to the surface of the celestial body. 2. Second Cosmic Velocity: Escape Velocity The second cosmic velocity is the speed needed for an object to escape the gravitational influence of a celestial body without any further propulsion. This is the minimum velocity required to overcome the gravitational potential energy of the body and reach an infinite distance from it. The second cosmic velocity \\(v_2\\) is given by: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(r\\) is the distance from the center of the celestial body to the object. This velocity is exactly \\(\\sqrt{2}\\) times the orbital velocity, and it's required for an object to break free from the celestial body's gravitational pull. 3. Third Cosmic Velocity: Solar Escape Velocity The third cosmic velocity is the speed needed to escape the gravitational pull of the Sun (or any star) and leave the solar system. This is the velocity at which an object must travel to escape the gravitational influence of the entire star system. The third cosmic velocity \\(v_3\\) is calculated using the formula: \\[ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{r_{\\text{sun}}}} \\] Where: - \\(G\\) is the gravitational constant, - \\(M_{\\text{sun}}\\) is the mass of the Sun, - \\(r_{\\text{sun}}\\) is the distance from the object to the Sun. In practical terms, the third cosmic velocity is extremely high and typically requires interplanetary travel technology to achieve, often involving multiple stages of propulsion. Task 2 : Analyzing the Mathematical Derivations and Parameters Affecting the Cosmic Velocities In this section, we will analyze the mathematical derivations of the first, second, and third cosmic velocities and explore the parameters that influence these velocities. Understanding these factors is essential for space exploration, as they determine the required energy for orbiting, escaping gravitational pulls, and interstellar travel. 1. Derivation of the First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is derived from the balance between the gravitational force and the centripetal force acting on an object in circular motion. The gravitational force between an object and a celestial body is given by: \\[ F_{\\text{gravity}} = \\frac{GMm}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(m\\) is the mass of the orbiting object, - \\(r\\) is the distance between the object and the center of the celestial body. For an object to be in a stable orbit, the gravitational force must equal the centripetal force, which is given by: \\[ F_{\\text{centripetal}} = \\frac{mv^2}{r} \\] Where: - \\(v\\) is the velocity of the orbiting object. Setting the gravitational force equal to the centripetal force: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Simplifying and solving for \\(v\\) , we obtain the first cosmic velocity: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Thus, the first cosmic velocity depends on the mass of the central body and the distance from the center of the celestial body. A higher mass or a smaller radius results in a higher orbital velocity. 2. Derivation of the Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the speed required to overcome the gravitational pull of a celestial body and escape its gravitational influence. This velocity is derived from the conservation of energy, specifically the total mechanical energy (kinetic + potential) of the object. The total mechanical energy of an object of mass \\(m\\) in the gravitational field of a celestial body of mass \\(M\\) at a distance \\(r\\) is the sum of its kinetic energy and gravitational potential energy: Kinetic energy: $$ K.E. = \\frac{1}{2}mv^2 $$ Gravitational potential energy: $$ U = -\\frac{GMm}{r} $$ To escape the gravitational pull, the total mechanical energy of the object must be zero (the object must have enough kinetic energy to overcome the negative potential energy): \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\(v\\) , we obtain the second cosmic velocity: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Thus, the second cosmic velocity is higher than the first cosmic velocity by a factor of \\(\\sqrt{2}\\) . It depends on the mass of the central body and the distance from the center of the body, similar to the first cosmic velocity, but with a larger factor to overcome the gravitational potential energy. 3. Derivation of the Third Cosmic Velocity (Solar Escape Velocity) The third cosmic velocity is the velocity required to escape the gravitational influence of the entire star system (e.g., the Solar System). It is derived from the same principle as the second cosmic velocity, but instead of escaping from a planet, the object must overcome the gravitational influence of the Sun. The total mechanical energy for an object at distance \\(r\\) from the Sun is: Kinetic energy: $$ K.E. = \\frac{1}{2}mv^2 $$ Gravitational potential energy: $$ U = -\\frac{GM_{\\text{sun}}m}{r} $$ For the object to escape the Sun's gravitational pull, the total mechanical energy must again be zero: \\[ \\frac{1}{2}mv^2 - \\frac{GM_{\\text{sun}}m}{r} = 0 \\] Solving for \\(v\\) , we obtain the third cosmic velocity: \\[ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{r}} \\] Where: - \\(M_{\\text{sun}}\\) is the mass of the Sun, - \\(r\\) is the distance from the object to the Sun. The third cosmic velocity is essentially the escape velocity from the Sun, and like the second cosmic velocity, it depends on the gravitational constant, the mass of the Sun, and the distance from the Sun. This velocity is much higher than the second cosmic velocity, as it involves escaping the gravitational field of an entire star system. 4. Parameters Affecting the Cosmic Velocities The key parameters that affect all three cosmic velocities are: Mass of the Central Body ( \\(M\\) ): A larger mass increases the gravitational pull, requiring a higher velocity to achieve orbit, escape, or leave the star system. The mass of the Sun ( \\(M_{\\text{sun}}\\) ) heavily influences the third cosmic velocity. Distance from the Central Body ( \\(r\\) ): A smaller distance from the center of the celestial body increases the required velocity. This is evident in the fact that the velocities are inversely proportional to the square root of the distance ( \\(r\\) ) in the formulas. Gravitational Constant ( \\(G\\) ): The gravitational constant is a universal factor that determines the strength of gravitational interactions between bodies. Its value affects all cosmic velocities in the same way. Task 3 : Calculating and Visualizing Cosmic Velocities for Different Celestial Bodies In this task, we will calculate and visualize the first, second, and third cosmic velocities for different celestial bodies such as Earth, Mars, and Jupiter. The calculations will help us understand how the mass and radius of different planets and moons affect the required velocities for orbiting, escaping, and leaving their gravitational influence. 1. Cosmic Velocity Formulas The formulas for the first, second, and third cosmic velocities are as follows: First Cosmic Velocity (Orbital Velocity): $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity (Escape Velocity): $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity (Solar Escape Velocity): $$ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{r_{\\text{sun}}}} $$ Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m \\(^3\\) kg \\(^{-1}\\) s \\(^{-2}\\) ), - \\(M\\) is the mass of the celestial body, - \\(r\\) is the radius of the celestial body, - \\(M_{\\text{sun}}\\) is the mass of the Sun ( \\(1.989 \\times 10^{30}\\) kg), - \\(r_{\\text{sun}}\\) is the distance from the object to the Sun (in the case of escape velocity from the Sun). 2. Python Script to Calculate and Visualize Cosmic Velocities The following Python script calculates and visualizes the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Data for Earth, Mars, and Jupiter celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6, \"distance_to_sun\": 1.496e11}, # Earth \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6, \"distance_to_sun\": 2.279e11}, # Mars \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7, \"distance_to_sun\": 7.785e11} # Jupiter } # Function to calculate the first cosmic velocity (orbital velocity) def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate the second cosmic velocity (escape velocity) def second_cosmic_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate the third cosmic velocity (solar escape velocity) def third_cosmic_velocity(distance_to_sun): return np.sqrt(2 * G * M_sun / distance_to_sun) # Calculate the velocities for each celestial body velocities = {} for body, data in celestial_bodies.items(): v1 = first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) # First cosmic velocity v2 = second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) # Second cosmic velocity v3 = third_cosmic_velocity(data[\"distance_to_sun\"]) # Third cosmic velocity velocities[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} # Plot the velocities labels = list(celestial_bodies.keys()) v1_values = [velocities[body][\"v1\"] / 1000 for body in labels] # Convert m/s to km/s v2_values = [velocities[body][\"v2\"] / 1000 for body in labels] # Convert m/s to km/s v3_values = [velocities[body][\"v3\"] / 1000 for body in labels] # Convert m/s to km/s # Plotting x = np.arange(len(labels)) fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - 0.2, v1_values, 0.6, label=\"First Cosmic Velocity (Orbital)\") ax.bar(x, v2_values, 0.6, label=\"Second Cosmic Velocity (Escape)\") ax.bar(x + 0.2, v3_values, 0.6, label=\"Third Cosmic Velocity (Solar Escape)\") ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt # Sample data (in case you're running just this cell) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7} } G = 6.67430e-11 # Calculate velocities def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) def second_cosmic_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Compute values labels = list(celestial_bodies.keys()) v1 = [first_cosmic_velocity(d[\"mass\"], d[\"radius\"])/1000 for d in celestial_bodies.values()] # km/s v2 = [second_cosmic_velocity(d[\"mass\"], d[\"radius\"])/1000 for d in celestial_bodies.values()] # km/s ratios = [v2[i]/v1[i] for i in range(len(labels))] # Create the plot plt.figure(figsize=(8, 6), facecolor='#f5f5f5') bars = plt.bar(labels, ratios, color=['#FF5722', '#607D8B', '#9C27B0'], edgecolor='black', alpha=0.8) plt.axhline(y=np.sqrt(2), color='red', linestyle='--', linewidth=2, label='Theoretical \u221a2 ratio') plt.xlabel('Celestial Body', fontsize=12, labelpad=10) plt.ylabel('Escape/Orbital Velocity Ratio', fontsize=12, labelpad=10) plt.title('Velocity Ratios Analysis', fontsize=14, pad=20, weight='bold') plt.grid(axis='y', linestyle='--', alpha=0.5) plt.legend(fontsize=11) # Add ratio values for bar in bars: height = bar.get_height() plt.text(bar.get_x() + bar.get_width()/2., height, f'{height:.3f}', ha='center', va='bottom', fontsize=11) plt.tight_layout() plt.show() Task 4 : 1. First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the minimum speed required for an object to stay in orbit around a celestial body. It is given by the formula: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: - \\( v_1 \\) is the orbital velocity (m/s), - \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} \\) ), - \\( M \\) is the mass of the central body (kg), - \\( r \\) is the orbital radius (m). For Earth, \\( v_1 \\approx 7.8 \\, \\text{km/s} \\) . The first cosmic velocity, or orbital velocity , is the speed required for a spacecraft to enter and maintain a stable orbit around a celestial body. This velocity is crucial for launching satellites into orbit around Earth or other planets. 2. Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the minimum velocity needed for an object to escape the gravitational pull of a celestial body. It is given by the formula: \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] Where: - \\( v_2 \\) is the escape velocity (m/s), - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body (kg), - \\( r \\) is the distance from the center of the celestial body (m). For Earth, \\( v_2 \\approx 11.2 \\, \\text{km/s} \\) . The second cosmic velocity, or escape velocity , is the minimum velocity needed for an object to escape the gravitational pull of a celestial body without any further propulsion. This is essential when sending spacecraft to other planets, moons, or deep space. 3. Third Cosmic Velocity (Solar Escape Velocity) The third cosmic velocity is the minimum velocity required to escape the gravitational influence of the Sun and leave the Solar System. It is given by the formula: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}}} \\] Where: - \\( v_3 \\) is the solar escape velocity (m/s), - \\( G \\) is the gravitational constant, - \\( M_{\\text{sun}} \\) is the mass of the Sun ( \\( 1.989 \\times 10^{30} \\, \\text{kg} \\) ), - \\( r_{\\text{sun}} \\) is the distance from the Sun to Earth ( \\( \\approx 1.496 \\times 10^{11} \\, \\text{m} \\) ). For Earth, \\( v_3 \\approx 16.7 \\, \\text{km/s} \\) . The third cosmic velocity, or solar escape velocity , is the speed required to break free from the Sun's gravitational influence and leave the Solar System entirely. This velocity is much higher than the second cosmic velocity, as it accounts for the Sun's mass and the vast distances involved in escaping the entire solar system. Summary of Velocities First Cosmic Velocity : \\( v_1 = \\sqrt{\\frac{G M}{r}} \\) Second Cosmic Velocity : \\( v_2 = \\sqrt{\\frac{2 G M}{r}} \\) Third Cosmic Velocity : \\( v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}}} \\)","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-1-defining-the-first-second-and-third-cosmic-velocities","text":"The concept of cosmic velocities refers to the minimum speeds needed for an object to achieve certain objectives in space: orbiting a celestial body, escaping its gravitational influence, and leaving a star system. These velocities are fundamental for space exploration and understanding how spacecraft interact with gravitational fields.","title":"Task 1 : Defining the First, Second, and Third Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the minimum velocity an object must have to enter a stable orbit around a celestial body. This velocity ensures that the object moves fast enough such that its trajectory bends in a circle, counteracting the pull of gravity. The first cosmic velocity \\(v_1\\) can be calculated using the formula: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m \\(^3\\) kg \\(^{-1}\\) s \\(^{-2}\\) ), - \\(M\\) is the mass of the celestial body (e.g., Earth, the Moon), - \\(r\\) is the distance from the center of the celestial body to the object (orbital radius). This velocity represents the speed required to stay in a circular orbit without falling back to the surface of the celestial body.","title":"1. First Cosmic Velocity: Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the speed needed for an object to escape the gravitational influence of a celestial body without any further propulsion. This is the minimum velocity required to overcome the gravitational potential energy of the body and reach an infinite distance from it. The second cosmic velocity \\(v_2\\) is given by: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(r\\) is the distance from the center of the celestial body to the object. This velocity is exactly \\(\\sqrt{2}\\) times the orbital velocity, and it's required for an object to break free from the celestial body's gravitational pull.","title":"2. Second Cosmic Velocity: Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-solar-escape-velocity","text":"The third cosmic velocity is the speed needed to escape the gravitational pull of the Sun (or any star) and leave the solar system. This is the velocity at which an object must travel to escape the gravitational influence of the entire star system. The third cosmic velocity \\(v_3\\) is calculated using the formula: \\[ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{r_{\\text{sun}}}} \\] Where: - \\(G\\) is the gravitational constant, - \\(M_{\\text{sun}}\\) is the mass of the Sun, - \\(r_{\\text{sun}}\\) is the distance from the object to the Sun. In practical terms, the third cosmic velocity is extremely high and typically requires interplanetary travel technology to achieve, often involving multiple stages of propulsion.","title":"3. Third Cosmic Velocity: Solar Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-2-analyzing-the-mathematical-derivations-and-parameters-affecting-the-cosmic-velocities","text":"In this section, we will analyze the mathematical derivations of the first, second, and third cosmic velocities and explore the parameters that influence these velocities. Understanding these factors is essential for space exploration, as they determine the required energy for orbiting, escaping gravitational pulls, and interstellar travel.","title":"Task 2 : Analyzing the Mathematical Derivations and Parameters Affecting the Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-derivation-of-the-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is derived from the balance between the gravitational force and the centripetal force acting on an object in circular motion. The gravitational force between an object and a celestial body is given by: \\[ F_{\\text{gravity}} = \\frac{GMm}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(m\\) is the mass of the orbiting object, - \\(r\\) is the distance between the object and the center of the celestial body. For an object to be in a stable orbit, the gravitational force must equal the centripetal force, which is given by: \\[ F_{\\text{centripetal}} = \\frac{mv^2}{r} \\] Where: - \\(v\\) is the velocity of the orbiting object. Setting the gravitational force equal to the centripetal force: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Simplifying and solving for \\(v\\) , we obtain the first cosmic velocity: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Thus, the first cosmic velocity depends on the mass of the central body and the distance from the center of the celestial body. A higher mass or a smaller radius results in a higher orbital velocity.","title":"1. Derivation of the First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-derivation-of-the-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the speed required to overcome the gravitational pull of a celestial body and escape its gravitational influence. This velocity is derived from the conservation of energy, specifically the total mechanical energy (kinetic + potential) of the object. The total mechanical energy of an object of mass \\(m\\) in the gravitational field of a celestial body of mass \\(M\\) at a distance \\(r\\) is the sum of its kinetic energy and gravitational potential energy: Kinetic energy: $$ K.E. = \\frac{1}{2}mv^2 $$ Gravitational potential energy: $$ U = -\\frac{GMm}{r} $$ To escape the gravitational pull, the total mechanical energy of the object must be zero (the object must have enough kinetic energy to overcome the negative potential energy): \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\(v\\) , we obtain the second cosmic velocity: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Thus, the second cosmic velocity is higher than the first cosmic velocity by a factor of \\(\\sqrt{2}\\) . It depends on the mass of the central body and the distance from the center of the body, similar to the first cosmic velocity, but with a larger factor to overcome the gravitational potential energy.","title":"2. Derivation of the Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-derivation-of-the-third-cosmic-velocity-solar-escape-velocity","text":"The third cosmic velocity is the velocity required to escape the gravitational influence of the entire star system (e.g., the Solar System). It is derived from the same principle as the second cosmic velocity, but instead of escaping from a planet, the object must overcome the gravitational influence of the Sun. The total mechanical energy for an object at distance \\(r\\) from the Sun is: Kinetic energy: $$ K.E. = \\frac{1}{2}mv^2 $$ Gravitational potential energy: $$ U = -\\frac{GM_{\\text{sun}}m}{r} $$ For the object to escape the Sun's gravitational pull, the total mechanical energy must again be zero: \\[ \\frac{1}{2}mv^2 - \\frac{GM_{\\text{sun}}m}{r} = 0 \\] Solving for \\(v\\) , we obtain the third cosmic velocity: \\[ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{r}} \\] Where: - \\(M_{\\text{sun}}\\) is the mass of the Sun, - \\(r\\) is the distance from the object to the Sun. The third cosmic velocity is essentially the escape velocity from the Sun, and like the second cosmic velocity, it depends on the gravitational constant, the mass of the Sun, and the distance from the Sun. This velocity is much higher than the second cosmic velocity, as it involves escaping the gravitational field of an entire star system.","title":"3. Derivation of the Third Cosmic Velocity (Solar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-parameters-affecting-the-cosmic-velocities","text":"The key parameters that affect all three cosmic velocities are: Mass of the Central Body ( \\(M\\) ): A larger mass increases the gravitational pull, requiring a higher velocity to achieve orbit, escape, or leave the star system. The mass of the Sun ( \\(M_{\\text{sun}}\\) ) heavily influences the third cosmic velocity. Distance from the Central Body ( \\(r\\) ): A smaller distance from the center of the celestial body increases the required velocity. This is evident in the fact that the velocities are inversely proportional to the square root of the distance ( \\(r\\) ) in the formulas. Gravitational Constant ( \\(G\\) ): The gravitational constant is a universal factor that determines the strength of gravitational interactions between bodies. Its value affects all cosmic velocities in the same way.","title":"4. Parameters Affecting the Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-3-calculating-and-visualizing-cosmic-velocities-for-different-celestial-bodies","text":"In this task, we will calculate and visualize the first, second, and third cosmic velocities for different celestial bodies such as Earth, Mars, and Jupiter. The calculations will help us understand how the mass and radius of different planets and moons affect the required velocities for orbiting, escaping, and leaving their gravitational influence.","title":"Task 3 : Calculating and Visualizing Cosmic Velocities for Different Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-cosmic-velocity-formulas","text":"The formulas for the first, second, and third cosmic velocities are as follows: First Cosmic Velocity (Orbital Velocity): $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity (Escape Velocity): $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity (Solar Escape Velocity): $$ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{r_{\\text{sun}}}} $$ Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m \\(^3\\) kg \\(^{-1}\\) s \\(^{-2}\\) ), - \\(M\\) is the mass of the celestial body, - \\(r\\) is the radius of the celestial body, - \\(M_{\\text{sun}}\\) is the mass of the Sun ( \\(1.989 \\times 10^{30}\\) kg), - \\(r_{\\text{sun}}\\) is the distance from the object to the Sun (in the case of escape velocity from the Sun).","title":"1. Cosmic Velocity Formulas"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-python-script-to-calculate-and-visualize-cosmic-velocities","text":"The following Python script calculates and visualizes the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Data for Earth, Mars, and Jupiter celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6, \"distance_to_sun\": 1.496e11}, # Earth \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6, \"distance_to_sun\": 2.279e11}, # Mars \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7, \"distance_to_sun\": 7.785e11} # Jupiter } # Function to calculate the first cosmic velocity (orbital velocity) def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate the second cosmic velocity (escape velocity) def second_cosmic_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate the third cosmic velocity (solar escape velocity) def third_cosmic_velocity(distance_to_sun): return np.sqrt(2 * G * M_sun / distance_to_sun) # Calculate the velocities for each celestial body velocities = {} for body, data in celestial_bodies.items(): v1 = first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) # First cosmic velocity v2 = second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) # Second cosmic velocity v3 = third_cosmic_velocity(data[\"distance_to_sun\"]) # Third cosmic velocity velocities[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} # Plot the velocities labels = list(celestial_bodies.keys()) v1_values = [velocities[body][\"v1\"] / 1000 for body in labels] # Convert m/s to km/s v2_values = [velocities[body][\"v2\"] / 1000 for body in labels] # Convert m/s to km/s v3_values = [velocities[body][\"v3\"] / 1000 for body in labels] # Convert m/s to km/s # Plotting x = np.arange(len(labels)) fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - 0.2, v1_values, 0.6, label=\"First Cosmic Velocity (Orbital)\") ax.bar(x, v2_values, 0.6, label=\"Second Cosmic Velocity (Escape)\") ax.bar(x + 0.2, v3_values, 0.6, label=\"Third Cosmic Velocity (Solar Escape)\") ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt # Sample data (in case you're running just this cell) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7} } G = 6.67430e-11 # Calculate velocities def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) def second_cosmic_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Compute values labels = list(celestial_bodies.keys()) v1 = [first_cosmic_velocity(d[\"mass\"], d[\"radius\"])/1000 for d in celestial_bodies.values()] # km/s v2 = [second_cosmic_velocity(d[\"mass\"], d[\"radius\"])/1000 for d in celestial_bodies.values()] # km/s ratios = [v2[i]/v1[i] for i in range(len(labels))] # Create the plot plt.figure(figsize=(8, 6), facecolor='#f5f5f5') bars = plt.bar(labels, ratios, color=['#FF5722', '#607D8B', '#9C27B0'], edgecolor='black', alpha=0.8) plt.axhline(y=np.sqrt(2), color='red', linestyle='--', linewidth=2, label='Theoretical \u221a2 ratio') plt.xlabel('Celestial Body', fontsize=12, labelpad=10) plt.ylabel('Escape/Orbital Velocity Ratio', fontsize=12, labelpad=10) plt.title('Velocity Ratios Analysis', fontsize=14, pad=20, weight='bold') plt.grid(axis='y', linestyle='--', alpha=0.5) plt.legend(fontsize=11) # Add ratio values for bar in bars: height = bar.get_height() plt.text(bar.get_x() + bar.get_width()/2., height, f'{height:.3f}', ha='center', va='bottom', fontsize=11) plt.tight_layout() plt.show()","title":"2. Python Script to Calculate and Visualize Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task-4-1-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the minimum speed required for an object to stay in orbit around a celestial body. It is given by the formula: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: - \\( v_1 \\) is the orbital velocity (m/s), - \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} \\) ), - \\( M \\) is the mass of the central body (kg), - \\( r \\) is the orbital radius (m). For Earth, \\( v_1 \\approx 7.8 \\, \\text{km/s} \\) .","title":"Task 4 : 1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#the-first-cosmic-velocity-or-orbital-velocity-is-the-speed-required-for-a-spacecraft-to-enter-and-maintain-a-stable-orbit-around-a-celestial-body-this-velocity-is-crucial-for-launching-satellites-into-orbit-around-earth-or-other-planets","text":"","title":"The first cosmic velocity, or orbital velocity, is the speed required for a spacecraft to enter and maintain a stable orbit around a celestial body. This velocity is crucial for launching satellites into orbit around Earth or other planets."},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity_1","text":"The second cosmic velocity is the minimum velocity needed for an object to escape the gravitational pull of a celestial body. It is given by the formula: \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] Where: - \\( v_2 \\) is the escape velocity (m/s), - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body (kg), - \\( r \\) is the distance from the center of the celestial body (m). For Earth, \\( v_2 \\approx 11.2 \\, \\text{km/s} \\) .","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#the-second-cosmic-velocity-or-escape-velocity-is-the-minimum-velocity-needed-for-an-object-to-escape-the-gravitational-pull-of-a-celestial-body-without-any-further-propulsion-this-is-essential-when-sending-spacecraft-to-other-planets-moons-or-deep-space","text":"","title":"The second cosmic velocity, or escape velocity, is the minimum velocity needed for an object to escape the gravitational pull of a celestial body without any further propulsion. This is essential when sending spacecraft to other planets, moons, or deep space."},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-solar-escape-velocity_1","text":"The third cosmic velocity is the minimum velocity required to escape the gravitational influence of the Sun and leave the Solar System. It is given by the formula: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}}} \\] Where: - \\( v_3 \\) is the solar escape velocity (m/s), - \\( G \\) is the gravitational constant, - \\( M_{\\text{sun}} \\) is the mass of the Sun ( \\( 1.989 \\times 10^{30} \\, \\text{kg} \\) ), - \\( r_{\\text{sun}} \\) is the distance from the Sun to Earth ( \\( \\approx 1.496 \\times 10^{11} \\, \\text{m} \\) ). For Earth, \\( v_3 \\approx 16.7 \\, \\text{km/s} \\) .","title":"3. Third Cosmic Velocity (Solar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#the-third-cosmic-velocity-or-solar-escape-velocity-is-the-speed-required-to-break-free-from-the-suns-gravitational-influence-and-leave-the-solar-system-entirely-this-velocity-is-much-higher-than-the-second-cosmic-velocity-as-it-accounts-for-the-suns-mass-and-the-vast-distances-involved-in-escaping-the-entire-solar-system","text":"","title":"The third cosmic velocity, or solar escape velocity, is the speed required to break free from the Sun's gravitational influence and leave the Solar System entirely. This velocity is much higher than the second cosmic velocity, as it accounts for the Sun's mass and the vast distances involved in escaping the entire solar system."},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary-of-velocities","text":"First Cosmic Velocity : \\( v_1 = \\sqrt{\\frac{G M}{r}} \\) Second Cosmic Velocity : \\( v_2 = \\sqrt{\\frac{2 G M}{r}} \\) Third Cosmic Velocity : \\( v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}}} \\)","title":"Summary of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"problem 3 Task 1: Analyze the Possible Trajectories of a Payload Released Near Earth When a payload is released near Earth from a moving rocket, its trajectory depends on various factors, including the initial conditions of the rocket and the gravitational forces acting on the object. These trajectories can be categorized as: Parabolic Trajectory : The object follows a curved path due to the combination of its initial velocity and the gravitational pull of the Earth. This trajectory occurs when the object\u2019s speed is just below the escape velocity. Hyperbolic Trajectory : This trajectory occurs when the object\u2019s speed is greater than the escape velocity, causing it to leave Earth\u2019s gravitational influence. Elliptical Trajectory : If the object's speed is less than the escape velocity but greater than the velocity for a circular orbit, it will follow an elliptical trajectory around Earth, with Earth located at one of the foci of the ellipse. Mathematical Model Newton's Law of Gravitation The force of gravity between two objects (e.g., Earth and the payload) is given by: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\(F\\) is the gravitational force, - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ), - \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ), - \\(m\\) is the mass of the payload, - \\(r\\) is the distance between the centers of the two masses. Orbital Mechanics We can describe the motion of an object near Earth using the vis-viva equation , which provides the speed of an object in orbit at a given distance from the center of the Earth: \\[ v(r) = \\sqrt{GM\\left(\\frac{2}{r} - \\frac{1}{a}\\right)} \\] Where: - \\(v(r)\\) is the velocity of the object at distance \\(r\\) , - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of Earth, - \\(a\\) is the semi-major axis of the orbit (the average of the periapsis and apoapsis distances). For each type of trajectory, the value of the semi-major axis \\(a\\) and the velocity at a given distance will determine the path of the object. Types of Trajectories Parabolic Trajectory : The total mechanical energy is zero, i.e., \\(E = 0\\) . $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 $$ Hyperbolic Trajectory : The total mechanical energy is positive, i.e., \\(E > 0\\) . $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} > 0 $$ Elliptical Trajectory : The total mechanical energy is negative, i.e., \\(E < 0\\) . $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} < 0 $$ Numerical Simulation Approach You can use numerical methods to simulate the payload\u2019s motion and visualize the different types of trajectories. For example, using Python and libraries like matplotlib for visualization and scipy.integrate for solving the equations of motion. Task 2: Perform a Numerical Analysis to Compute the Path of the Payload In this task, we will perform a numerical analysis to compute the path of the payload based on given initial conditions, including position, velocity, and altitude. The goal is to simulate the trajectory of the object under the influence of Earth's gravitational force. Assumptions and Initial Conditions For the numerical analysis, we need to assume some initial conditions. These include: - Initial position : The initial distance from the Earth's center (altitude + Earth's radius). - Initial velocity : The initial speed and direction of the payload. - Altitude : The height above the Earth's surface from which the payload is released. We will also assume the Earth is a perfect sphere and the gravitational force is central and acts radially. Governing Equations The equations governing the motion of the payload under gravitational attraction can be derived from Newton's second law and Newton's law of gravitation. The position vector \\(\\vec{r}(t)\\) evolves according to the following differential equations: \\[ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{GM}{r^2} \\hat{r} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the Earth, - \\(r\\) is the radial distance from the center of the Earth, - \\(\\hat{r}\\) is the unit vector in the direction of the position. We will solve these equations numerically using methods like Euler\u2019s method or Runge-Kutta . Numerical Solution Approach We will discretize time into small steps and use numerical integration to calculate the position and velocity of the payload at each time step. We'll use Python and the scipy.integrate library to solve the system of equations. Python Code for Numerical Simulation Below is a Python script that performs the numerical integration and simulates the trajectory of the payload. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # Mass of the Earth in kg R_earth = 6371000 # Radius of the Earth in meters # Initial conditions (example values) altitude = 100000 # Altitude above Earth's surface in meters initial_velocity = 7500 # Initial velocity in m/s (tangential) theta = np.pi / 4 # Angle for the velocity (45 degrees) # Initial position vector (radial distance from Earth's center) r0 = R_earth + altitude # Initial velocity components vx0 = initial_velocity * np.cos(theta) vy0 = initial_velocity * np.sin(theta) # Initial state vector [x, y, vx, vy] initial_state = [r0, 0, vx0, vy0] # Gravitational force function def gravitational_acceleration(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Time span for the simulation t_span = (0, 6000) # Time in seconds (e.g., 6000 seconds ~ 1.67 hours) # Time points to evaluate the solution t_eval = np.linspace(t_span[0], t_span[1], 1000) # Solve the system of differential equations solution = solve_ivp(gravitational_acceleration, t_span, initial_state, t_eval=t_eval) # Extract the solution x, y = solution.y[0], solution.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label=\"Trajectory\") plt.scatter(0, 0, color='red', label=\"Earth's Center\") plt.title(\"Payload Trajectory Near Earth\") plt.xlabel(\"X position (m)\") plt.ylabel(\"Y position (m)\") plt.legend() plt.axis('equal') plt.grid(True) plt.show() # Extract velocity components vx, vy = solution.y[2], solution.y[3] # Plot velocity components over time (X and Y velocities) plt.figure(figsize=(8, 6)) plt.plot(solution.t, vx, label=\"X velocity\", color='green') plt.plot(solution.t, vy, label=\"Y velocity\", color='purple') plt.title(\"Velocity Components vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Velocity (m/s)\") plt.legend() plt.grid(True) plt.show() ## Task 3 : 1. Orbital Insertion (Elliptical Orbit) To achieve orbital insertion , a spacecraft must have the right velocity to enter an elliptical orbit around a celestial body. The velocity required for an elliptical orbit can be calculated using the orbital velocity formula : Orbital Velocity (for an elliptical trajectory): \\[ v = \\sqrt{\\frac{G M}{r}} \\] Where: - \\( v \\) is the orbital velocity (m/s), - \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} \\) ), - \\( M \\) is the mass of the central body (e.g., Earth), - \\( r \\) is the orbital radius (m), which is the distance from the center of the celestial body. For circular orbits, the velocity must be adjusted to maintain a stable orbit, typically at the apogee for circularization. 2. Reentry (Parabolic Trajectory) During reentry , a spacecraft follows a parabolic trajectory that brings it back into the atmosphere. The reentry velocity can be approximated using the escape velocity formula for the surface of the Earth. Escape Velocity (for reentry trajectories): \\[ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\] Where: - \\( v_{\\text{escape}} \\) is the escape velocity (m/s), - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the Earth (or another celestial body), - \\( r \\) is the distance from the center of the Earth (radius of Earth). The object must be slowed down enough to enter a predictable and controlled parabolic trajectory as it re-enters the atmosphere. 3. Escape (Hyperbolic Trajectory) To escape a celestial body\u2019s gravity, an object must be launched at a velocity greater than the escape velocity , which allows it to follow a hyperbolic trajectory . Escape Velocity (for escaping Earth's gravity): \\[ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\] Where: - \\( v_{\\text{escape}} \\) is the escape velocity (m/s), - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the celestial body (e.g., Earth), - \\( r \\) is the distance from the center of the celestial body (m), which is the altitude at which the object is located. If the object is launched with a velocity higher than this value, it will follow a hyperbolic trajectory , escaping the gravitational pull of the celestial body. Summary of Relevant Formulas: Orbital Velocity (Elliptical Trajectory) : [ v = \\sqrt{\\frac{G M}{r}} ] Escape Velocity (Reentry & Escape) : [ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} ] Task 4: Develop a Computational Tool to Simulate and Visualize the Motion of the Payload Under Earth's Gravity In this task, we will develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions. The goal is to create a Python tool that can be used to simulate the trajectory of a payload released from a rocket, with the ability to modify initial conditions (position, velocity, and direction). Approach and Tools To simulate the motion of the payload, we will: 1. Define initial conditions for the position, velocity, and angle of release. 2. Use numerical methods (such as Euler\u2019s method or the Runge-Kutta method) to solve the equations of motion. 3. Visualize the trajectory using matplotlib to plot the path of the payload. Governing Equations As discussed in previous tasks, the motion of the payload is governed by Newton's law of gravitation. The position and velocity are updated over time according to: \\[ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{GM}{r^2} \\hat{r} \\] Where: - \\(\\vec{r}\\) is the position vector, - \\(r\\) is the radial distance from Earth\u2019s center, - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of Earth, - \\(\\hat{r}\\) is the unit vector in the radial direction. Key Components of the Tool The tool will include the following features: - Initial Conditions Input : The user can specify the altitude, velocity, and direction of the payload. - Numerical Integration : The equations of motion will be solved using numerical methods like the Runge-Kutta method for more accurate results. - Visualization : A graphical representation of the trajectory will be displayed, showing the path of the payload as it moves under Earth's gravity. Python Code Implementation Below is the Python script that simulates and visualizes the motion of the payload: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # Mass of the Earth in kg R_earth = 6371000 # Radius of the Earth in meters # Function to define the equations of motion under gravity def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 # Gravitational acceleration in the x-direction ay = -G * M * y / r**3 # Gravitational acceleration in the y-direction return [vx, vy, ax, ay] # Function to simulate the motion def simulate_motion(altitude, velocity, angle, time_span=(0, 6000), num_points=1000): # Initial position vector (radial distance from Earth's center) r0 = R_earth + altitude # Initial velocity components vx0 = velocity * np.cos(angle) vy0 = velocity * np.sin(angle) # Initial state vector [x, y, vx, vy] initial_state = [r0, 0, vx0, vy0] # Time points to evaluate the solution t_eval = np.linspace(time_span[0], time_span[1], num_points) # Solve the system of differential equations solution = solve_ivp(equations_of_motion, time_span, initial_state, t_eval=t_eval) return solution # Plotting function def plot_trajectory(solution): # Extract the solution x, y = solution.y[0], solution.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label=\"Payload Trajectory\") plt.scatter(0, 0, color='red', label=\"Earth's Center\", s=100) plt.title(\"Payload Trajectory Near Earth\") plt.xlabel(\"X position (m)\") plt.ylabel(\"Y position (m)\") plt.legend() plt.axis('equal') plt.grid(True) plt.show() # Example usage if __name__ == \"__main__\": # Define initial conditions (altitude in meters, velocity in m/s, angle in radians) altitude = 100000 # Altitude above Earth's surface in meters velocity = 7500 # Initial velocity in m/s (tangential) angle = np.pi / 4 # Launch angle (45 degrees) # Simulate the motion solution = simulate_motion(altitude, velocity, angle) # Plot the trajectory plot_trajectory(solution) plt.figure(figsize=(8, 6)) plt.plot(solution.t, y, label=\"Y position\", color='orange') plt.title(\"Y Position vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Y position (m)\") plt.grid(True) plt.show() plt.figure(figsize=(8, 6)) plt.plot(solution.t, x, label=\"X position\") plt.title(\"X Position vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"X position (m)\") plt.grid(True) plt.show()","title":"problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-1-analyze-the-possible-trajectories-of-a-payload-released-near-earth","text":"When a payload is released near Earth from a moving rocket, its trajectory depends on various factors, including the initial conditions of the rocket and the gravitational forces acting on the object. These trajectories can be categorized as: Parabolic Trajectory : The object follows a curved path due to the combination of its initial velocity and the gravitational pull of the Earth. This trajectory occurs when the object\u2019s speed is just below the escape velocity. Hyperbolic Trajectory : This trajectory occurs when the object\u2019s speed is greater than the escape velocity, causing it to leave Earth\u2019s gravitational influence. Elliptical Trajectory : If the object's speed is less than the escape velocity but greater than the velocity for a circular orbit, it will follow an elliptical trajectory around Earth, with Earth located at one of the foci of the ellipse.","title":"Task 1: Analyze the Possible Trajectories of a Payload Released Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#mathematical-model","text":"","title":"Mathematical Model"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"The force of gravity between two objects (e.g., Earth and the payload) is given by: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\(F\\) is the gravitational force, - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ), - \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ), - \\(m\\) is the mass of the payload, - \\(r\\) is the distance between the centers of the two masses.","title":"Newton's Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-mechanics","text":"We can describe the motion of an object near Earth using the vis-viva equation , which provides the speed of an object in orbit at a given distance from the center of the Earth: \\[ v(r) = \\sqrt{GM\\left(\\frac{2}{r} - \\frac{1}{a}\\right)} \\] Where: - \\(v(r)\\) is the velocity of the object at distance \\(r\\) , - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of Earth, - \\(a\\) is the semi-major axis of the orbit (the average of the periapsis and apoapsis distances). For each type of trajectory, the value of the semi-major axis \\(a\\) and the velocity at a given distance will determine the path of the object.","title":"Orbital Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Parabolic Trajectory : The total mechanical energy is zero, i.e., \\(E = 0\\) . $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 $$ Hyperbolic Trajectory : The total mechanical energy is positive, i.e., \\(E > 0\\) . $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} > 0 $$ Elliptical Trajectory : The total mechanical energy is negative, i.e., \\(E < 0\\) . $$ E = \\frac{1}{2}mv^2 - \\frac{GMm}{r} < 0 $$","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-approach","text":"You can use numerical methods to simulate the payload\u2019s motion and visualize the different types of trajectories. For example, using Python and libraries like matplotlib for visualization and scipy.integrate for solving the equations of motion.","title":"Numerical Simulation Approach"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-2-perform-a-numerical-analysis-to-compute-the-path-of-the-payload","text":"In this task, we will perform a numerical analysis to compute the path of the payload based on given initial conditions, including position, velocity, and altitude. The goal is to simulate the trajectory of the object under the influence of Earth's gravitational force.","title":"Task 2: Perform a Numerical Analysis to Compute the Path of the Payload"},{"location":"1%20Physics/2%20Gravity/Problem_3/#assumptions-and-initial-conditions","text":"For the numerical analysis, we need to assume some initial conditions. These include: - Initial position : The initial distance from the Earth's center (altitude + Earth's radius). - Initial velocity : The initial speed and direction of the payload. - Altitude : The height above the Earth's surface from which the payload is released. We will also assume the Earth is a perfect sphere and the gravitational force is central and acts radially.","title":"Assumptions and Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"The equations governing the motion of the payload under gravitational attraction can be derived from Newton's second law and Newton's law of gravitation. The position vector \\(\\vec{r}(t)\\) evolves according to the following differential equations: \\[ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{GM}{r^2} \\hat{r} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the Earth, - \\(r\\) is the radial distance from the center of the Earth, - \\(\\hat{r}\\) is the unit vector in the direction of the position. We will solve these equations numerically using methods like Euler\u2019s method or Runge-Kutta .","title":"Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-solution-approach","text":"We will discretize time into small steps and use numerical integration to calculate the position and velocity of the payload at each time step. We'll use Python and the scipy.integrate library to solve the system of equations.","title":"Numerical Solution Approach"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-for-numerical-simulation","text":"Below is a Python script that performs the numerical integration and simulates the trajectory of the payload. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # Mass of the Earth in kg R_earth = 6371000 # Radius of the Earth in meters # Initial conditions (example values) altitude = 100000 # Altitude above Earth's surface in meters initial_velocity = 7500 # Initial velocity in m/s (tangential) theta = np.pi / 4 # Angle for the velocity (45 degrees) # Initial position vector (radial distance from Earth's center) r0 = R_earth + altitude # Initial velocity components vx0 = initial_velocity * np.cos(theta) vy0 = initial_velocity * np.sin(theta) # Initial state vector [x, y, vx, vy] initial_state = [r0, 0, vx0, vy0] # Gravitational force function def gravitational_acceleration(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Time span for the simulation t_span = (0, 6000) # Time in seconds (e.g., 6000 seconds ~ 1.67 hours) # Time points to evaluate the solution t_eval = np.linspace(t_span[0], t_span[1], 1000) # Solve the system of differential equations solution = solve_ivp(gravitational_acceleration, t_span, initial_state, t_eval=t_eval) # Extract the solution x, y = solution.y[0], solution.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label=\"Trajectory\") plt.scatter(0, 0, color='red', label=\"Earth's Center\") plt.title(\"Payload Trajectory Near Earth\") plt.xlabel(\"X position (m)\") plt.ylabel(\"Y position (m)\") plt.legend() plt.axis('equal') plt.grid(True) plt.show() # Extract velocity components vx, vy = solution.y[2], solution.y[3] # Plot velocity components over time (X and Y velocities) plt.figure(figsize=(8, 6)) plt.plot(solution.t, vx, label=\"X velocity\", color='green') plt.plot(solution.t, vy, label=\"Y velocity\", color='purple') plt.title(\"Velocity Components vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Velocity (m/s)\") plt.legend() plt.grid(True) plt.show() ## Task 3 : 1. Orbital Insertion (Elliptical Orbit) To achieve orbital insertion , a spacecraft must have the right velocity to enter an elliptical orbit around a celestial body. The velocity required for an elliptical orbit can be calculated using the orbital velocity formula :","title":"Python Code for Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-velocity-for-an-elliptical-trajectory","text":"\\[ v = \\sqrt{\\frac{G M}{r}} \\] Where: - \\( v \\) is the orbital velocity (m/s), - \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} \\) ), - \\( M \\) is the mass of the central body (e.g., Earth), - \\( r \\) is the orbital radius (m), which is the distance from the center of the celestial body. For circular orbits, the velocity must be adjusted to maintain a stable orbit, typically at the apogee for circularization.","title":"Orbital Velocity (for an elliptical trajectory):"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-reentry-parabolic-trajectory","text":"During reentry , a spacecraft follows a parabolic trajectory that brings it back into the atmosphere. The reentry velocity can be approximated using the escape velocity formula for the surface of the Earth.","title":"2. Reentry (Parabolic Trajectory)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity-for-reentry-trajectories","text":"\\[ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\] Where: - \\( v_{\\text{escape}} \\) is the escape velocity (m/s), - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the Earth (or another celestial body), - \\( r \\) is the distance from the center of the Earth (radius of Earth). The object must be slowed down enough to enter a predictable and controlled parabolic trajectory as it re-enters the atmosphere.","title":"Escape Velocity (for reentry trajectories):"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-escape-hyperbolic-trajectory","text":"To escape a celestial body\u2019s gravity, an object must be launched at a velocity greater than the escape velocity , which allows it to follow a hyperbolic trajectory .","title":"3. Escape (Hyperbolic Trajectory)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity-for-escaping-earths-gravity","text":"\\[ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\] Where: - \\( v_{\\text{escape}} \\) is the escape velocity (m/s), - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the celestial body (e.g., Earth), - \\( r \\) is the distance from the center of the celestial body (m), which is the altitude at which the object is located. If the object is launched with a velocity higher than this value, it will follow a hyperbolic trajectory , escaping the gravitational pull of the celestial body.","title":"Escape Velocity (for escaping Earth's gravity):"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary-of-relevant-formulas","text":"Orbital Velocity (Elliptical Trajectory) : [ v = \\sqrt{\\frac{G M}{r}} ] Escape Velocity (Reentry & Escape) : [ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} ]","title":"Summary of Relevant Formulas:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task-4-develop-a-computational-tool-to-simulate-and-visualize-the-motion-of-the-payload-under-earths-gravity","text":"In this task, we will develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions. The goal is to create a Python tool that can be used to simulate the trajectory of a payload released from a rocket, with the ability to modify initial conditions (position, velocity, and direction).","title":"Task 4: Develop a Computational Tool to Simulate and Visualize the Motion of the Payload Under Earth's Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#approach-and-tools","text":"To simulate the motion of the payload, we will: 1. Define initial conditions for the position, velocity, and angle of release. 2. Use numerical methods (such as Euler\u2019s method or the Runge-Kutta method) to solve the equations of motion. 3. Visualize the trajectory using matplotlib to plot the path of the payload.","title":"Approach and Tools"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations_1","text":"As discussed in previous tasks, the motion of the payload is governed by Newton's law of gravitation. The position and velocity are updated over time according to: \\[ \\frac{d^2 \\vec{r}}{dt^2} = -\\frac{GM}{r^2} \\hat{r} \\] Where: - \\(\\vec{r}\\) is the position vector, - \\(r\\) is the radial distance from Earth\u2019s center, - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of Earth, - \\(\\hat{r}\\) is the unit vector in the radial direction.","title":"Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-components-of-the-tool","text":"The tool will include the following features: - Initial Conditions Input : The user can specify the altitude, velocity, and direction of the payload. - Numerical Integration : The equations of motion will be solved using numerical methods like the Runge-Kutta method for more accurate results. - Visualization : A graphical representation of the trajectory will be displayed, showing the path of the payload as it moves under Earth's gravity.","title":"Key Components of the Tool"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-implementation","text":"Below is the Python script that simulates and visualizes the motion of the payload: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # Mass of the Earth in kg R_earth = 6371000 # Radius of the Earth in meters # Function to define the equations of motion under gravity def equations_of_motion(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 # Gravitational acceleration in the x-direction ay = -G * M * y / r**3 # Gravitational acceleration in the y-direction return [vx, vy, ax, ay] # Function to simulate the motion def simulate_motion(altitude, velocity, angle, time_span=(0, 6000), num_points=1000): # Initial position vector (radial distance from Earth's center) r0 = R_earth + altitude # Initial velocity components vx0 = velocity * np.cos(angle) vy0 = velocity * np.sin(angle) # Initial state vector [x, y, vx, vy] initial_state = [r0, 0, vx0, vy0] # Time points to evaluate the solution t_eval = np.linspace(time_span[0], time_span[1], num_points) # Solve the system of differential equations solution = solve_ivp(equations_of_motion, time_span, initial_state, t_eval=t_eval) return solution # Plotting function def plot_trajectory(solution): # Extract the solution x, y = solution.y[0], solution.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label=\"Payload Trajectory\") plt.scatter(0, 0, color='red', label=\"Earth's Center\", s=100) plt.title(\"Payload Trajectory Near Earth\") plt.xlabel(\"X position (m)\") plt.ylabel(\"Y position (m)\") plt.legend() plt.axis('equal') plt.grid(True) plt.show() # Example usage if __name__ == \"__main__\": # Define initial conditions (altitude in meters, velocity in m/s, angle in radians) altitude = 100000 # Altitude above Earth's surface in meters velocity = 7500 # Initial velocity in m/s (tangential) angle = np.pi / 4 # Launch angle (45 degrees) # Simulate the motion solution = simulate_motion(altitude, velocity, angle) # Plot the trajectory plot_trajectory(solution) plt.figure(figsize=(8, 6)) plt.plot(solution.t, y, label=\"Y position\", color='orange') plt.title(\"Y Position vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Y position (m)\") plt.grid(True) plt.show() plt.figure(figsize=(8, 6)) plt.plot(solution.t, x, label=\"X position\") plt.title(\"X Position vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"X position (m)\") plt.grid(True) plt.show()","title":"Python Code Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Task: Circular Wave Interference from a Point Source Wave Equation A circular wave on the water surface, emanating from a point source located at $ (x_0, y_0) $, can be described by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos (kr - \\omega t + \\phi) \\] where: $ \\eta(x, y, t) $ = displacement of the water surface at point $ (x, y) $ and time $ t $. $ A $ = amplitude of the wave. $ k = \\frac{2\\pi}{\\lambda} $ = wave number, related to the wavelength $ \\lambda $. $ \\omega = 2\\pi f $ = angular frequency, related to the frequency $ f $. $ r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} $ = distance from the source to point $ (x, y) $. $ \\phi $ = initial phase. Wave Properties 1. Relationship Between Wavelength, Frequency, and Speed The wave speed $ v $ is related to frequency and wavelength: \\[ v = f \\lambda \\] 2. Wave Energy The energy of a wave is proportional to the square of the amplitude: \\[ E \\propto A^2 \\] 3. Superposition of Multiple Waves If multiple wave sources exist, the total displacement is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where $ N $ is the number of sources. Graphical Representation 1. Circular Wave from a Single Source import numpy as np import matplotlib.pyplot as plt # Define parameters A = 1 lambda_ = 1 f = 1 omega = 2 * np.pi * f k = 2 * np.pi / lambda_ x0, y0 = 0, 0 phi = 0 # Create grid x = np.linspace(-5, 5, 200) y = np.linspace(-5, 5, 200) X, Y = np.meshgrid(x, y) # Compute distance from source R = np.sqrt((X - x0)**2 + (Y - y0)**2) # Compute wave displacement at t=0 eta = (A / np.sqrt(R + 1e-6)) * np.cos(k * R + phi) # Plot plt.figure(figsize=(6, 6)) plt.contourf(X, Y, eta, levels=50, cmap='coolwarm') plt.colorbar(label=\"Wave Displacement\") plt.scatter(x0, y0, color='black', marker='o', label=\"Wave Source\") plt.legend() plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.title(\"Circular Wave from a Point Source\") plt.show()","title":"Task: Circular Wave Interference from a Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#task-circular-wave-interference-from-a-point-source","text":"","title":"Task: Circular Wave Interference from a Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation","text":"A circular wave on the water surface, emanating from a point source located at $ (x_0, y_0) $, can be described by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos (kr - \\omega t + \\phi) \\] where: $ \\eta(x, y, t) $ = displacement of the water surface at point $ (x, y) $ and time $ t $. $ A $ = amplitude of the wave. $ k = \\frac{2\\pi}{\\lambda} $ = wave number, related to the wavelength $ \\lambda $. $ \\omega = 2\\pi f $ = angular frequency, related to the frequency $ f $. $ r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} $ = distance from the source to point $ (x, y) $. $ \\phi $ = initial phase.","title":"Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-properties","text":"","title":"Wave Properties"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-relationship-between-wavelength-frequency-and-speed","text":"The wave speed $ v $ is related to frequency and wavelength: \\[ v = f \\lambda \\]","title":"1. Relationship Between Wavelength, Frequency, and Speed"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-wave-energy","text":"The energy of a wave is proportional to the square of the amplitude: \\[ E \\propto A^2 \\]","title":"2. Wave Energy"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-superposition-of-multiple-waves","text":"If multiple wave sources exist, the total displacement is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] where $ N $ is the number of sources.","title":"3. Superposition of Multiple Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#graphical-representation","text":"","title":"Graphical Representation"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-circular-wave-from-a-single-source","text":"import numpy as np import matplotlib.pyplot as plt # Define parameters A = 1 lambda_ = 1 f = 1 omega = 2 * np.pi * f k = 2 * np.pi / lambda_ x0, y0 = 0, 0 phi = 0 # Create grid x = np.linspace(-5, 5, 200) y = np.linspace(-5, 5, 200) X, Y = np.meshgrid(x, y) # Compute distance from source R = np.sqrt((X - x0)**2 + (Y - y0)**2) # Compute wave displacement at t=0 eta = (A / np.sqrt(R + 1e-6)) * np.cos(k * R + phi) # Plot plt.figure(figsize=(6, 6)) plt.contourf(X, Y, eta, levels=50, cmap='coolwarm') plt.colorbar(label=\"Wave Displacement\") plt.scatter(x0, y0, color='black', marker='o', label=\"Wave Source\") plt.legend() plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.title(\"Circular Wave from a Point Source\") plt.show()","title":"1. Circular Wave from a Single Source"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}